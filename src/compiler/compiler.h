/* Copyright 2007 Andrea Autiero, Simone Basso.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this client except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

/**
 * @file compiler/compiler.h
 * Compiler main header.
 */

#include<string.h>
#include<stdlib.h>
#include<stdio.h>
#pragma once

/**
 * @defgroup compiler Compiler
 * @{
 *
 * The <b>compiler</b> translates the <i>C-like input language</i> into the
 * <i>assembly-like output language</i>. In particular, each function in the
 * input language is translated into a <b>symbol table entry</b> that
 * references an <b>assembly code block</b>, implemented in vm_instr structure.
 * Therefore, compiler main goal is to create such code block, given the
 * assembly instructions that each <b>simple instruction</b> generate. There
 * are two types of simple instructions in the input language:
 *
 * <ul>
 *   <li>Comparison instructions;</li>
 *   <li>The exec() function.</li>
 * </ul>
 *
 * The former type generates three assembly instructions: one to actually
 * evaluate the result comparing two registers, and two conditional jumps for
 * the true and false case. We assume that the virtual machine sets an internal
 * flag after the comparison instruction, to be checked by the following
 * conditional jumps. The latter type generates just one assembly instruction.
 *
 * At this point, it should be obvious that we may have two different basic
 * code blocks. Infact, the block generated by comparison evaluation
 * instructions may jump to two different locations, depending on the result;
 * while the one generated by exec() instruction always jump to a location
 * which is the next code block. We define <b>comparison code block</b> the
 * former, and <b>complete code block</b> the latter.
 *
 * For handling this differencies, we wrap code blocks with another structure:
 * the <b>parse tree node</b>, implemented in p_node. Such polimorphic struct
 * may reference two different data types:
 *
 * <ul>
 *  <li>A block of code during its lifecycle;</li>
 *  <li>A lexeme passed from scanner.</li>
 * </ul>
 *
 * As its name suggests, p_node represent a node in the parsing tree, which
 * is a tree defined by parser rules. Note that we don't explicitly build the
 * tree, which will be a memory consuming task; instead, each parser rule
 * consumes one or more input nodes to create an output node. When a node
 * is no longer needed, it is destroyed. Furthermore, we keep a cache of
 * unused nodes, to avoid invoking the operating system for dynamical memory
 * too often. There is a specific section that outligths memory management.
 *
 * There are four different types of p_node:
 *
 * <pre>
 *   unused     : managed by the unused node cache
 *   lexeme     : references a lexeme
 *   complete   : references a complete code block
 *   comparison : references a comparison code block
 * </pre>
 *
 * The parse tree is layered in four levels:
 *
 * <ol>
 *   <li><i>Simple instruction translation;</i></li>
 *   <li><i>Boolean expression evaluation;</i></li>
 *   <li><i>Control flow instruction evaluation;</i></li>
 *   <li><i>Next-block chaining.</i></li>
 * </ol>
 *
 * In the first layer the compiler creates parsing tree nodes, either complete
 * or comparison, depending on the input file. At this point, it is not known
 * which is the next location for complete nodes, and which are the true and
 * false location to jump to for comparison ones. This problem is solved
 * keeping a list of instructions that reference unknown locations within a
 * node. When a locations becomes known, such list is walked, patching the
 * instructions with the proper offset. For implementing this tecnique,
 * known as <b>backpatching</b>, we use bp_entry structure.
 *
 * In the second layer boolean expressions are evaluated. This is implemented
 * concatenating code blocks, and merging or backpatching true and false lists.
 * For instance, in case of <i>boolean and</i>, the result node merges the
 * true lists of original nodes, and backpatches the false list of the first
 * one to jump at the beginning of the second's code block.
 *
 * In the third layer control flow instructions are evaluated. The side effect
 * is that all true and false locations becomes known, so the final node will
 * have just a nextlist to backpatch. Infact, at this point, the node does not
 * known which the next code block will be. Note that, at the end of this
 * layer, we will have around complete nodes only.
 *
 * In the fourth layer we chain complete nodes, until the parser reduces a
 * complete function. When we have a complete function, we add
 * <code>VM_RETURN</code> instruction to the code block, and we patch nextlist
 * with the location of such instruction. The result is a code block without
 * unknown locations, which is installed in the symbol table, using the
 * function name as lookup key.
 */

/** Available assembly instructions. */
typedef enum vm_opcode {
    /** Do nothing instruction. */
    VM_NOP,
    /** Execute an external program. */
    VM_EXEC,
    /** Set trueflag if two strings equal. */
    VM_EQ,
    /** Set trueflag if the first string is major than the second. */
    VM_MAG,
    /** Set trueflag if the first string is minor than the second. */
    VM_MIN,
    /** Set trueflag if the first string is not minor than the second. */
    VM_MAEQ,
    /** Set trueflag if the first string is not major than the second. */
    VM_MIEQ,
    /** Set trueflag if two strings differ. */
    VM_NEQ,
    /** Jump to location if trueflag is set. */
    VM_JTRUE,
    /** Jump to location if trueflag isn't set. */
    VM_JFALSE,
    /** Jump to location. */
    VM_JMP,
    /** Return from function. */
    VM_RETURN
} vm_opcode;

/** Assembly instruction. */
typedef struct vm_instr {
    /** Instruction offset. */
    unsigned offset;
    /** Instruction opcode. */
    vm_opcode opcode;
    /** Anonymous union for arguments. */
    union {
        /** Anonymous struct for comparison instructions arguments. */
        struct {
            /** First argument for comparison instructions. */
            char * arg1;
            /** Second argument for comparison instructions. */
            char * arg2;
        };
        /** Location to jump to. */
        unsigned location;
    };
} vm_instr;

/** Entry in backpatch list. */
typedef struct bp_entry {
    /** Next entry in backpatch list. */
    struct bp_entry *next;
    /** Reference to instruction to backpatch. */
    vm_instr *instr;
} bp_entry;

/** Parsing tree node. */
typedef struct p_node {
    /** For node cache to store unused nodes. */
    struct p_node *next;
    /** False list for backpatching of comparison nodes. */
    bp_entry *falselist;
    /** True list for backpatching of comparison nodes.*/
    bp_entry *truelist;
    /** Next list for backpatching of complete nodes. */
    bp_entry *nextlist;
    /** Code block referenced by this node, for non lexeme nodes. */
    vm_instr *code;
    /** Lexeme referenced by this node, for lexeme nodes only. */
    char *lexeme;
} p_node;

/**
 * @defgroup parsetree Parse tree layers
 * @{
 * @defgroup NBC Next-block chaining
 * @{
 */

/**
 * Install an entry for function @a name in symbol table.
 * @param name Lexeme node that references function name.
 * @param param Lexeme node that references function parameter name.
 * @param body Complete node that references a code block.
 */
extern void code_eval_FUNC(p_node *name, p_node *param, p_node *body);

/**
 * Chain two complete nodes into another complete node.
 * @param body Complete node.
 * @param if_or_exec Complete node.
 * @return The complete node merge of @a body and @a if_or_exec.
 */
extern p_node *code_eval_BODY(p_node *body, p_node *if_or_exec);

/**
 * @}
 * @defgroup controlflow Control flow instruction evalutation
 * @{
 */

/**
 * Evaluate IF control flow instruction.
 * @param condlist Comparison node that contains code to evaluate condition.
 * @param body Complete code that contains IF body.
 * @return The complete node merge of @a condlist and @a body.
 */
extern p_node *code_eval_IF(p_node *condlist, p_node *body);

/**
 * Evaluate IF...ELSE control flow instruction.
 * @param condlist Comparison node that contains code to evaluate condition.
 * @param if_body Complete code that contains IF body.
 * @param else_body Complete code that contains ELSE body.
 * @return The complete node merge of @a condlist, @a if_body and @a else_body.
 */
extern p_node *code_eval_IF_ELSE(p_node *condlist, p_node *if_body,
                                 p_node *else_body);

/**
 * @}
 * @defgroup boolean Boolean expression evaluation.
 * @{
 */

/**
 * Evaluate AND boolean expression.
 * @param l Comparison node for left operand.
 * @param r Comparison node for right operand.
 * @returns Comparison node merge of @a l and @a r.
 */
extern p_node *code_eval_AND(p_node *l, p_node *r);

/**
 * Evaluate OR boolean expression.
 * @param l Comparison node for left operand.
 * @param r Comparison node for right operand.
 * @returns Comparison node merge of @a l and @a r.
 */
extern p_node *code_eval_OR(p_node *l, p_node *r);

/**
 * Evaluate NOT boolean expression.
 * @param node Comparison node for operand.
 * @returns Comparison node negation of @a node.
 */
extern p_node *code_eval_NOT(p_node *node);

/**
 * @}
 * @defgroup simple Simple instruction translation
 * @{
 */

/**
 * Generate code for EQ instruction.
 * @param l Lexeme node for left parameter.
 * @param r Lexeme node for left operator.
 * @returns Comparison node merge of @a l and @a r.
 */
extern p_node *code_gen_EQ(p_node *l, p_node *r);

/**
 * Generate code for MAG instruction.
 * @param l Lexeme node for left parameter.
 * @param r Lexeme node for left operator.
 * @returns Comparison node merge of @a l and @a r.
 */
extern p_node *code_gen_MAG(p_node *l, p_node *r);

/**
 * Generate code for MIN instruction.
 * @param l Lexeme node for left parameter.
 * @param r Lexeme node for left operator.
 * @returns Comparison node merge of @a l and @a r.
 */
extern p_node *code_gen_MIN(p_node *l, p_node *r);

/**
 * Generate code for MAEQ instruction.
 * @param l Lexeme node for left parameter.
 * @param r Lexeme node for left operator.
 * @returns Comparison node merge of @a l and @a r.
 */
extern p_node *code_gen_MAEQ(p_node *l, p_node *r);

/**
 * Generate code for MIEQ instruction.
 * @param l Lexeme node for left parameter.
 * @param r Lexeme node for left operator.
 * @returns Comparison node merge of @a l and @a r.
 */
extern p_node *code_gen_MIEQ(p_node *l, p_node *r);

/**
 * Generate code for NEQ instruction.
 * @param l Lexeme node for left parameter.
 * @param r Lexeme node for left operator.
 * @returns Comparison node merge of @a l and @a r.
 */
extern p_node *code_gen_NEQ(p_node *l, p_node *r);

/**
 * Generate code for NOP instruction.
 * @returns Complete node that references VM_NOP instruction.
 */
extern p_node *code_gen_NOP(void);

/**
 * Generate code for EXEC instruction.
 * @param node_string Lexeme node containing string to execute.
 * @returns Complete node that references VM_EXEC instruction.
 */
extern p_node *code_gen_EXEC(p_node *node_string);

/**
 * Maps function parameter field to VM register.
 * @param param Lexeme node that references function parameter name.
 * @param field Lexeme node that references function parameter field name.
 * @returns Lexeme node that references VM register name.
 */
extern p_node *code_eval_ID_P_ID(p_node *param, p_node *field);

/**
 * Create a lexeme node.
 * @param lexeme Lexeme for node.
 * @returns Lexeme node.
 */
extern p_node *p_node_create(const char * lexeme);

/**
 * @}
 * @}
 */

/** Initialize code generation subsystem. */
extern void subsys_code_init(void);

/** Output all the code generated so far. */
extern void code_generate(void);

/** This is the type that will be used in parser and scanner. */
#define YYSTYPE p_node *

/**
 * @}
 */

extern int yylex(void);

extern int yyparse(void);

extern FILE *yyin;

extern void yyerror(char const * str);

#ifdef DEBUG
#include<stdarg.h>
#endif

static inline void debug(const char *fmt, ...)
{
#ifdef DEBUG
    va_list ap;
    fputs("debug: ", stderr);
    va_start(ap, fmt);
    vfprintf(stderr, fmt, ap);
    fputc('\n', stderr);
    va_end(ap);
#endif
}

